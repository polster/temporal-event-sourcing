= Temporal event sourcing - Hands-on
:toc:

== Introduction

=== What's this?

This hands-on project explores temporal event sourcing with Spring Boot, Kafka, and PostgreSQL.

It also offers a REST API and a separate GraphQL API, using the same event-sourced data but with a database view.

=== Prerequisites

* Java 21
* Maven 3.8 or higher
* make, direnv
* Docker, Docker Compose

=== Infrastructure

|===
| Resource | Description

| http://localhost:16543/browser[]
| PostgreSQL Admin UI

| http://localhost:8081/ui/artifacts[]
| Schema registry UI

| http://localhost:4588/int/swagger-ui/index.html[]
| Swagger UI

| http://localhost:8083[]
| Kafka UI
|===

== Get started

=== Initial setup

* Clone the repository
* Provision the infrastructure:
[source,bash]
----
make docker-infra-up
# Provision the DB with Flyway
make database-migrate
# Upload message schemas to schema registry
make schema-provision
----
* Build and verify:
[source,bash]
----
mvn clean install
----

[#rest-api-demo]
=== Demo: REST API

* Via IDE or CLI, start all the available services: link:services/[]
** Pay attention to first start the link:services/campaign-events-processor/[] and then the link:services/campaign-events-generator/[]
* Check logs and verify there are no errors
* Connect to the DB using link:http://localhost:16543/browser[pgadmin] and check if the materialized data has been written
* Open link:http://localhost:4588/int/swagger-ui/index.html[Swagger-UI] in your favourite browser
* Start querying

=== Demo: GraphQL

* Walk-through the steps in link:#rest-api-demo[REST API demo]
* Open link:http://localhost:4588/int/graphiql?path=/ext/v1/campaigns/graphql[GraphiQL] in your favourite browser
* Or, import the available link:etc/postman/temporal-event-sourcing.postman_collection.json[Postman collection] into Postman
* Start querying

== Hints

=== Spring Boot JPA and Views

By intention this project uses a `view` to materialize the data. This is not to be confused with materialized views with the DBMS (ordinary views always reflect the latest data from the underlying tables, while materialized views only show the data from the last refresh).

For more details, see the following resources:

* link:services/campaign-data-service/src/main/kotlin/io/dietschi/edu/temporal_event_sourcing/campaign_data_service/adapters/outbound/persistence/campaign_with_views/PostgresCampaignWithViewsRepository.kt[View repository]
* link:services/campaign-data-service/src/main/kotlin/io/dietschi/edu/temporal_event_sourcing/campaign_data_service/adapters/outbound/persistence/campaign_with_views/CampaignWithCompletedViews.kt[View entity]
* link:services/campaign-data-service/src/main/kotlin/io/dietschi/edu/temporal_event_sourcing/campaign_data_service/adapters/outbound/persistence/campaign_with_views/CompositeId.kt[View composite ID]
* link:etc/flyway/db/migration/V2_0_0__view.sql[View creation script]